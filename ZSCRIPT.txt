version "4.0"

class BoosterJetsHandler : EventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'RedSphere':
			case 'PortableHealingItemBigger':
			case 'SSGReplaces':
				if (random() <= 8)
				{
					e.Replacement = "HDBoosterJets";
					e.IsFinal = true;
				}
				break;
		}
	}
}

class HDBoosterJets : HDPickup
{
	override void BeginPlay()
	{
		InternalBattery = 100;

		Super.BeginPlay();
	}

	private void Bang()
	{
		owner.A_StartSound("jetpack/bang", 10, pitch: 1 + frandom(-0.2, 0.2));
		
		let Exp = Spawn("HDExplosion", (owner.pos.xy, owner.pos.z - 20), ALLOW_REPLACE);
		Exp.vel.z -= 20;
		Exp.vel.xy += AngleToVector(owner.angle + angle, 6);
		Exp.deathsound = "jetpack/bang";
	}

	override void DoEffect()
	{
		ReactivationTics--;

		let plr = HDPlayerPawn(owner);
		if (Active)
		{
			if (level.time % 2 == 0)
			{
				plr.A_StartSound("jetpack/fwoosh", CHAN_AUTO, CHANF_DEFAULT, 0.3, pitch: 1.6 + 0.2 * (level.time & (1 | 2))); // [Ace] I have no idea how these bitwise ORs work or why they're there.
			}
			if (DrainTicks++ >= 105)
			{
				DrainTicks = 0;
				InternalBattery--;
			}

			if (InternalBattery <= 0 || plr.incapacitated > 0)
			{
				InternalBattery = max(0, InternalBattery);
				Active = false;
			}

			int buttons = plr.player.cmd.buttons;
			int oldbuttons = plr.player.oldbuttons;
			bool JustPressedJump = buttons & BT_JUMP && !(oldbuttons & BT_JUMP);
			bool IsPressingJump = buttons & BT_JUMP;
			bool IsPressingSprint = buttons & BT_SPEED;

			if (JustPressedJump && ReactivationTics <= 0)
			{
				int Cost = int(min(5, 5 * plr.CheckEncumbrance()));
				if (InternalBattery >= Cost)
				{
					ReactivationTics = 30;
					Bang();
					plr.vel.z += IsPressingSprint ? 8 : 15;
					plr.vel.xy *= IsPressingSprint ? 2.25 : 1.5;
					plr.DamageMobj(plr, plr, 10, 'Bashing');
					InternalBattery -= Cost;
				}
				else
				{
					plr.A_Log("You are overburdened.", true);
				}
			}
		}
		else if (InternalBattery < 100 && RechargeTicks++ >= 10)
		{
			RechargeTicks = 0;

			int Index, Charge;
			let Battery = HDBattery(owner.FindInventory("HDBattery"));
			[Index, Charge] = GetLowestBattery(Battery, 1);
			if (Index > -1)
			{
				if (!random(0, 5))
				{
					Battery.Mags[Index]--;
				}
				InternalBattery++;
			}
		}

		Super.DoEffect();
	}

	override int GetSbarNum(int flags)
	{
		let HDHud = HDStatusBar(StatusBar);
		HDHud.SavedColour = Active ? Font.CR_GREEN : Font.CR_RED;
		return InternalBattery;
	}

	private clearscope int, int GetLowestBattery(HDBattery stack, int minCharge)
	{
		if (stack)
		{
			int LowestIndex = stack.Mags.Size() - 1;
			int LowestCharge = stack.MaxPerUnit;
			for (int i = LowestIndex; i >= 0; --i)
			{
				if (stack.Mags[i] >= minCharge && stack.Mags[i] <= LowestCharge)
				{
					LowestIndex = i;
					LowestCharge = stack.Mags[i];
				}
			}

			return LowestIndex, stack.Mags[LowestIndex];
		}

		return -1, 0;
	}

	private bool Active;
	private int InternalBattery;
	private int ReactivationTics;
	private int DrainTicks;
	private int RechargeTicks;

	Default
	{
		+HDPICKUP.CHEATNOGIVE
		+HDPICKUP.NOTINPOCKETS
		-HDPICKUP.DROPTRANSLATION
		+INVENTORY.INVBAR
		HDPickup.Bulk 140;
		HDPickup.RefID "bsj";
		Inventory.MaxAmount 3;
		Inventory.Icon "BSJTA0";
		Inventory.PickupMessage "Picked up the booster jets.";
		Scale 0.7;
		Tag "Booster Jets";
	}

	States
	{
		Spawn:
			BSJT A -1;
			Stop;
		Use:
			TNT1 A 0
			{
				A_StartSound("jetpack/wear", CHAN_WEAPON);
				invoker.Active = !invoker.Active;
			}
			Fail;
	}
}